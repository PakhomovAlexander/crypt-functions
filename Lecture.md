# Гаммирование
Шифр цезаря A-Я, Б-А...   это на одну позицию 
Матемаматически это можно записать так: 
```code ci == ai + b (mod 32)``` тут ai это исходный текст в позиции i, 
```code ai = {1..31}, ci - шифротекст = {1..32}, b = const.``` У нас это 31. 
Это плохо. 
Заменим b на гамму и это будет ключ
```code ci == ai + yi (mod 32)```
```code ai == ci - yi (mod 32)```
```code y = (y1,...,yi), y = (y1,.., yj, y1..,yi,...) ```

Пример:
y'= (5,1,24)
y'= (5,1,24,5,1,24,5)


# Криптосистемы с открытым ключем. Цифровая подпись
## Односторонние функции
Пусть у нас есть множества X и Y и функция f: X -> Y 
Найти x: f(x) = y 
1) таких х нет 
2) Е! x0 f(x0) = y 
3) E несколько x1, x2, f(xi) = y
Операция поиска икс называеся инвертированием.
Замечание: в случае 2 мы говорим что функция f обратима и обратную к f обозначаем f^-1(y) = x
F^-1 o f : X -> X - тождественное отображение.

**Одностороння функция** - это функция f, для которой выполнены след 2 усл: 
1) Существует полиминеальный алгоритм вычисления f
2) Не существует полиминомиального алгорима инвертирования f 

Замечание: хотя такие функции пока не найдены,  при стоении криптосистем исполльзуются кандидаты на звание односторонней функции. 
Пример кандидата:
```
fa,m(x') = (a^x)'(mod m) {0,...,m-1}
```

Определение: Пусть fk: X -> Y функция fk называется **функцией с ловушкой**, если выпонены три условия:
1) Для любых k и x существует полиминеальный алгоритм вычисления fk(x)
2) При известном k существует полиминеальный алгоритм инвертирования fk
3) При неизвестном k не существует полиминеального алгоритма инвертирования fk(x)

Замечание: ситуация с примерами для функции с секретом такая же как и для односторонней функции. 
```
n,m из N
gn,m = Zm -> Zm
gn,m(x') = x'^n(mod m)
-> "модульное возведение в степень"
<- взятие корня n-ой степени по модулю m
секрет m = m1^a1 * ... * mj^ai 
```

Замечание: Односторонние функции, как и функции с секретом не используются непосредственно при шифровании и дешифровании, а в процессе генерации. 

## Алгоритм Diffie Hellman "наивный" 
A и Б решили организовать переписку по незащищенному каналу связи. 
Для организации переписки требуется сформировать ключ, причем сделать это без передачи по каналу связи 
1) Один из абонентов (А) выбирает 2 достаточно больших числа **m** и **q**  A -> B
2) x == q^a (mod m)   A -> B
3) y == q^b (mod m)   B -> A
4) A вычисляет k1 = y^a (mod m), B вычисляет k2 = x^b (mod m)

Фокус **k1 = k2 = k**
m,q,x,y - открытый ключ 
a, b,k - секретный ключ

### Примитивные элементы поля Zp
Zp = {0,1,...,p-1}
p - простое
j из Zp, j != 0

*Определение*: Порядком элемента j называется число **k** такое, что 
1) j^m != 1, Для любого 1 <= m <= k-1
2) j^k = 1 ord(j,p) = k

*Определение*: элемент q из Zp называется **примитивным элементом**, если ```ord(q,p) = p-1```

*Замечание 1*: ясно, что если q примитивный элемент, то ```<q> = Z \ {0}```, другими словами, циклическая группа q совпадает с мультипликативной группой обратимы в поле 
Zp элементов.

*Замечание 2*:В алгоритме Диффи Хелмана в качестве q стоит выбирать примитавный элемент поля Zm

Задача:
Вычислить все примитивные элементы в поле Zp

#### Утверждение
1) Примитивные элементы всегда существуют
2) Число примитивных элементов поля Zp равно: ф(p-1)

##### Доказательство 
- (i)  G - конечная Абелева группа, а - элемент максимального порядка 
     < a > = {a^n, n из Z} => ord(d) : ord(x)  для любого x из G 
- (ii) Любой многочлен сетепени n  от одной переменной и с коэффициэнтами из поля K имеет в поле K не более чем N корней

(см Лекции) (БУДЕТ НА КР!)

## Пример атаки на алгоритм Диффи Хелмана 

Без сертификации открытых ключей данный алгоритм уязвим с точки зрения "человека по середине". Предположим, что злоумышленник **M** может не только додслушиивать сообщения, но и незаметно для Алисы и Боба удалять сообщения, подменяя их на собственные, тогда **M** может выдавать себя ща Алису и Боба соответственно.

x == q^a (mod m)

A:  x ->  
:M(a'):  x' ->  
:B: x'==q^a' (mod m) y==q^b (mod m) -> 
:(y)M(y',b'): -> 
:A k1' == y'^a (mod m) == q^(ab') (mod m) == (q^a)^b' (mod m) == x^b' (mod m)
:B k2' = (x')^b (mob m) == q^(a'b) (mod m)

## Крипто система без передачи ключей

A и B решили организовать секретную переписку. В системе известно некоторое достаточно большое простое число **P**,   
A и B форируют ключи независимо 
1) Они выбирают числа **a** и **b** так, что бы **gcd(a,p-1) = 1** и **gcd(b,p-1) = 1**
2) Теперь они вычислают секретный ключ **a * a1 == 1 (mod ф(p))** и **b * b1 == 1 (mod ф(p))**

Теперь рассмотрим передачу сообщений 

text 

T(text) = m  - оператор, который ставит в соответствые тексту чило, он обратимый

Процесс шифрации: 
- A вычисляет число m1 используя сектретный ключ
m1 == m^a1 (mod p)
- B вычисляет m2 == m1^b1 (mod p)
- A вычисляет m3 == 
m2^a1 (mod p)
- A вычисляет m4 == m3^b1 (mod p)
- m == m4 (mod p)
- B приминяет пребразование T к m 

### Общая формула для решения Ax == B (mod M)

x == B * A^ф(M)-1 (mod M)

