# Гаммирование
Шифр цезаря A-Я, Б-А...   это на одну позицию 
Матемаматически это можно записать так: 
```code ci == ai + b (mod 32)``` тут ai это исходный текст в позиции i, 
```code ai = {1..31}, ci - шифротекст = {1..32}, b = const.``` У нас это 31. 
Это плохо. 
Заменим b на гамму и это будет ключ
```code ci == ai + yi (mod 32)```
```code ai == ci - yi (mod 32)```
```code y = (y1,...,yi), y = (y1,.., yj, y1..,yi,...) ```

Пример:
y'= (5,1,24)
y'= (5,1,24,5,1,24,5)


# Криптосистемы с открытым ключем. Цифровая подпись
## Односторонние функции
Пусть у нас есть множества X и Y и функция f: X -> Y 
Найти x: f(x) = y 
1) таких х нет 
2) Е! x0 f(x0) = y 
3) E несколько x1, x2, f(xi) = y
Операция поиска икс называеся инвертированием.
Замечание: в случае 2 мы говорим что функция f обратима и обратную к f обозначаем f^-1(y) = x
F^-1 o f : X -> X - тождественное отображение.

**Одностороння функция** - это функция f, для которой выполнены след 2 усл: 
1) Существует полиминеальный алгоритм вычисления f
2) Не существует полиминомиального алгорима инвертирования f 

Замечание: хотя такие функции пока не найдены,  при стоении криптосистем исполльзуются кандидаты на звание односторонней функции. 
Пример кандидата:
```
fa,m(x') = (a^x)'(mod m) {0,...,m-1}
```

Определение: Пусть fk: X -> Y функция fk называется **функцией с ловушкой**, если выпонены три условия:
1) Для любых k и x существует полиминеальный алгоритм вычисления fk(x)
2) При известном k существует полиминеальный алгоритм инвертирования fk
3) При неизвестном k не существует полиминеального алгоритма инвертирования fk(x)

Замечание: ситуация с примерами для функции с секретом такая же как и для односторонней функции. 
```
n,m из N
gn,m = Zm -> Zm
gn,m(x') = x'^n(mod m)
-> "модульное возведение в степень"
<- взятие корня n-ой степени по модулю m
секрет m = m1^a1 * ... * mj^ai 
```

Замечание: Односторонние функции, как и функции с секретом не используются непосредственно при шифровании и дешифровании, а в процессе генерации. 

## Алгоритм Diffie Hellman "наивный" 
A и Б решили организовать переписку по незащищенному каналу связи. 
Для организации переписки требуется сформировать ключ, причем сделать это без передачи по каналу связи 
1) Один из абонентов (А) выбирает 2 достаточно больших числа **m** и **q**  A -> B
2) x == q^a (mod m)   A -> B
3) y == q^b (mod m)   B -> A
4) A вычисляет k1 = y^a (mod m), B вычисляет k2 = x^b (mod m)

Фокус **k1 = k2 = k**
m,q,x,y - открытый ключ 
a, b,k - секретный ключ

### Примитивные элементы поля Zp
Zp = {0,1,...,p-1}
p - простое
j из Zp, j != 0

*Определение*: Порядком элемента j называется число **k** такое, что 
1) j^m != 1, Для любого 1 <= m <= k-1
2) j^k = 1 ord(j,p) = k

*Определение*: элемент q из Zp называется **примитивным элементом**, если ```ord(q,p) = p-1```

*Замечание 1*: ясно, что если q примитивный элемент, то ```<q> = Z \ {0}```, другими словами, циклическая группа q совпадает с мультипликативной группой обратимы в поле 
Zp элементов.

*Замечание 2*:В алгоритме Диффи Хелмана в качестве q стоит выбирать примитавный элемент поля Zm

Задача:
Вычислить все примитивные элементы в поле Zp

#### Утверждение
1) Примитивные элементы всегда существуют
2) Число примитивных элементов поля Zp равно: ф(p-1)

##### Доказательство 
- (i)  G - конечная Абелева группа, а - элемент максимального порядка 
     < a > = {a^n, n из Z} => ord(d) : ord(x)  для любого x из G 
- (ii) Любой многочлен сетепени n  от одной переменной и с коэффициэнтами из поля K имеет в поле K не более чем N корней

(см Лекции) (БУДЕТ НА КР!)

## Пример атаки на алгоритм Диффи Хелмана 

Без сертификации открытых ключей данный алгоритм уязвим с точки зрения "человека по середине". Предположим, что злоумышленник **M** может не только додслушиивать сообщения, но и незаметно для Алисы и Боба удалять сообщения, подменяя их на собственные, тогда **M** может выдавать себя ща Алису и Боба соответственно.

x == q^a (mod m)

A:  x ->  
:M(a'):  x' ->  
:B: x'==q^a' (mod m) y==q^b (mod m) -> 
:(y)M(y',b'): -> 
:A k1' == y'^a (mod m) == q^(ab') (mod m) == (q^a)^b' (mod m) == x^b' (mod m)
:B k2' = (x')^b (mob m) == q^(a'b) (mod m)

## Крипто система без передачи ключей

A и B решили организовать секретную переписку. В системе известно некоторое достаточно большое простое число **P**,   
A и B форируют ключи независимо 
1) Они выбирают числа **a** и **b** так, что бы **gcd(a,p-1) = 1** и **gcd(b,p-1) = 1**
2) Теперь они вычислают секретный ключ **a * a1 == 1 (mod ф(p))** и **b * b1 == 1 (mod ф(p))**

Теперь рассмотрим передачу сообщений 

text 

T(text) = m  - оператор, который ставит в соответствые тексту чило, он обратимый

Процесс шифрации: 
- A вычисляет число m1 используя сектретный ключ
m1 == m^a1 (mod p)
- B вычисляет m2 == m1^b1 (mod p)
- A вычисляет m3 == 
m2^a1 (mod p)
- A вычисляет m4 == m3^b1 (mod p)
- m == m4 (mod p)
- B приминяет пребразование T к m 

### Общая формула для решения Ax == B (mod M)

x == B * A^ф(M)-1 (mod M)

#### Прием для возведения в степень с модулем 
x, N, p

y == x^N (mod p)

N1 = отаток от деления N на 10^n, где n - некоторый фиксированный параметр, определяемый эксперементально. 

N2 = (N - N1)\10^n => N = N2*10^n + N1

y == x^(N2*10^n + N1) mod p

x1 == x^N1 mod p => y == x1^(10^n) * x2 (mod p) 

## Меркль-Хелман

Последовательность не отрицательных чисел x1, x2,..., xn называется **супервозрастающей**, если каждый последующий елемент строго больше суммы предыдущих. 

A <- B

1) W = (W1, ..., Wn) - A выбирает случайно, так что W - супервозрастающая
2) выбирает q, r, q > r, q > SUM(1, n)wi, gcd(q, r) = 1
3) вычисление a = rwi (mod q), a = (a1,...,an) - a это открытый ключ
4) (w, q, r) - секретный ключ
5) ЭТАП ШИФРОВАНИЯ по буквам: 
-  m = (m1, .., mn), mi из {1,0}, 
- S = SUM(1,n)aimi 
6) ЭТАП РАСШИФРОВКИ: 
- r1 = r^(-1) из Zq 
-  S' = Sr1 (mod q)
- m исходя из S' 

Задача: как вычислить  m из S' ??

Решение:
1) mn = S' >= Wn ? 1 : 0; 
2) mn-1 = S1 - mnWn >= Wn-1 ? 1 : 0; e.i


## Вероятностная схема шифрования Эль-Гамаля

Одним из способов повышения криптостойкости является использование случайных величин 
в качестве параметров шифрования. Соответствующие криптосистемы называют **вероятностными**. 
В качестве примера приведем схему Эль-Гамаля. 

Боб ожидает получения сообщения от Алисы, он проводит генерацию ключей:
1) Боб: Выбирается P - достаточно большое простое число
2) Боб: Выбирается g - примитивный элемент в поле Zp, случайным образом
3) Боб: Выбирает случайный x из {1, ..., P-1}
4) Боб: Вычисляет y == g^x (mod P)

После этого Боб отправляет Алисе 3 числа:  (p, g, y) - открытый ключ, x - секретный ключ

Алиса хочет передать сообщение: Q из {1, ..., p-1}. Получив открытый ключ, Алиса выбирает 
**сессионный ключ k** из {1, .., p-1} и вычисляет a == g^k (mod p) и b == Qy^k (mod p)
и передает (a, b) - шифротекст Бобу. 

Боб вычисляет исходное сообщение по формуле Q == b(a^x)^-1 (mod P)

Задача 1: Докажите, что Q действительно является шифротекстом. 
Задача 2: Криптоаналитик догадалс, что Алиса использует всегда один и тот же сесссионный ключ, 
первое сообщение быглядело от нее выглядело вот так:  (a1, b1)
данное сообщение носило технический характер и было расшифорованно аналитиком как Q1. 
ПОсле этого Алиса отправила второе сообщение: (a2, b2), определите Q2. 
Q2 = Q1*b2*(b2^-1) (mod p)

Алисса и Боб решили обменяться секратными сообщениями с использованием процедуры Гаммирования, 
для формарования Гаммы они воспользовалисись схемой Эль-Гамаля 